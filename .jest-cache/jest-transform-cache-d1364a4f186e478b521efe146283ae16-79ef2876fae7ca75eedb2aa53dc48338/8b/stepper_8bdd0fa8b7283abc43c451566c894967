c841a83c7b3590de2ec4e2929906fe8d
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var stepper_exports = {};
__export(stepper_exports, {
  CdkStep: () => CdkStep,
  CdkStepHeader: () => CdkStepHeader,
  CdkStepLabel: () => CdkStepLabel,
  CdkStepper: () => CdkStepper,
  CdkStepperModule: () => CdkStepperModule,
  CdkStepperNext: () => CdkStepperNext,
  CdkStepperPrevious: () => CdkStepperPrevious,
  STEPPER_GLOBAL_OPTIONS: () => STEPPER_GLOBAL_OPTIONS,
  STEP_STATE: () => STEP_STATE,
  StepperSelectionEvent: () => StepperSelectionEvent
});
module.exports = __toCommonJS(stepper_exports);
var import_a11y = require("@angular/cdk/a11y");
var i1 = __toESM(require("@angular/cdk/bidi"), 1);
var import_bidi = require("@angular/cdk/bidi");
var import_keycodes = require("@angular/cdk/keycodes");
var i0 = __toESM(require("@angular/core"), 1);
var import_core = require("@angular/core");
var import_forms = require("@angular/forms");
var import_platform = require("@angular/cdk/platform");
var import_rxjs = require("rxjs");
var import_operators = require("rxjs/operators");
const _CdkStepHeader = class _CdkStepHeader {
  constructor(_elementRef) {
    this._elementRef = _elementRef;
  }
  /** Focuses the step header. */
  focus() {
    this._elementRef.nativeElement.focus();
  }
};
_CdkStepHeader.\u0275fac = i0.\u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "18.2.0-next.2", ngImport: i0, type: _CdkStepHeader, deps: [{ token: i0.ElementRef }], target: i0.\u0275\u0275FactoryTarget.Directive });
_CdkStepHeader.\u0275dir = i0.\u0275\u0275ngDeclareDirective({ minVersion: "14.0.0", version: "18.2.0-next.2", type: _CdkStepHeader, isStandalone: true, selector: "[cdkStepHeader]", host: { attributes: { "role": "tab" } }, ngImport: i0 });
let CdkStepHeader = _CdkStepHeader;
i0.\u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.0-next.2", ngImport: i0, type: CdkStepHeader, decorators: [{
  type: import_core.Directive,
  args: [{
    selector: "[cdkStepHeader]",
    host: {
      "role": "tab"
    },
    standalone: true
  }]
}], ctorParameters: () => [{ type: i0.ElementRef }] });
const _CdkStepLabel = class _CdkStepLabel {
  constructor(template) {
    this.template = template;
  }
};
_CdkStepLabel.\u0275fac = i0.\u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "18.2.0-next.2", ngImport: i0, type: _CdkStepLabel, deps: [{ token: i0.TemplateRef }], target: i0.\u0275\u0275FactoryTarget.Directive });
_CdkStepLabel.\u0275dir = i0.\u0275\u0275ngDeclareDirective({ minVersion: "14.0.0", version: "18.2.0-next.2", type: _CdkStepLabel, isStandalone: true, selector: "[cdkStepLabel]", ngImport: i0 });
let CdkStepLabel = _CdkStepLabel;
i0.\u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.0-next.2", ngImport: i0, type: CdkStepLabel, decorators: [{
  type: import_core.Directive,
  args: [{
    selector: "[cdkStepLabel]",
    standalone: true
  }]
}], ctorParameters: () => [{ type: i0.TemplateRef }] });
let nextId = 0;
class StepperSelectionEvent {
}
const STEP_STATE = {
  NUMBER: "number",
  EDIT: "edit",
  DONE: "done",
  ERROR: "error"
};
const STEPPER_GLOBAL_OPTIONS = new import_core.InjectionToken("STEPPER_GLOBAL_OPTIONS");
const _CdkStep = class _CdkStep {
  /** Whether step is marked as completed. */
  get completed() {
    return this._completedOverride == null ? this._getDefaultCompleted() : this._completedOverride;
  }
  set completed(value) {
    this._completedOverride = value;
  }
  _getDefaultCompleted() {
    return this.stepControl ? this.stepControl.valid && this.interacted : this.interacted;
  }
  /** Whether step has an error. */
  get hasError() {
    return this._customError == null ? this._getDefaultError() : this._customError;
  }
  set hasError(value) {
    this._customError = value;
  }
  _getDefaultError() {
    return this.stepControl && this.stepControl.invalid && this.interacted;
  }
  constructor(_stepper, stepperOptions) {
    this._stepper = _stepper;
    this.interacted = false;
    this.interactedStream = new import_core.EventEmitter();
    this.editable = true;
    this.optional = false;
    this._completedOverride = null;
    this._customError = null;
    this._stepperOptions = stepperOptions ? stepperOptions : {};
    this._displayDefaultIndicatorType = this._stepperOptions.displayDefaultIndicatorType !== false;
  }
  /** Selects this step component. */
  select() {
    this._stepper.selected = this;
  }
  /** Resets the step to its initial state. Note that this includes resetting form data. */
  reset() {
    var _a;
    this.interacted = false;
    if (this._completedOverride != null) {
      this._completedOverride = false;
    }
    if (this._customError != null) {
      this._customError = false;
    }
    if (this.stepControl) {
      (_a = this._childForms) == null ? void 0 : _a.forEach((form) => {
        var _a2;
        return (_a2 = form.resetForm) == null ? void 0 : _a2.call(form);
      });
      this.stepControl.reset();
    }
  }
  ngOnChanges() {
    this._stepper._stateChanged();
  }
  _markAsInteracted() {
    if (!this.interacted) {
      this.interacted = true;
      this.interactedStream.emit(this);
    }
  }
  /** Determines whether the error state can be shown. */
  _showError() {
    var _a;
    return (_a = this._stepperOptions.showError) != null ? _a : this._customError != null;
  }
};
_CdkStep.\u0275fac = i0.\u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "18.2.0-next.2", ngImport: i0, type: _CdkStep, deps: [{ token: (0, import_core.forwardRef)(() => CdkStepper) }, { token: STEPPER_GLOBAL_OPTIONS, optional: true }], target: i0.\u0275\u0275FactoryTarget.Component });
_CdkStep.\u0275cmp = i0.\u0275\u0275ngDeclareComponent({ minVersion: "16.1.0", version: "18.2.0-next.2", type: _CdkStep, isStandalone: true, selector: "cdk-step", inputs: { stepControl: "stepControl", label: "label", errorMessage: "errorMessage", ariaLabel: ["aria-label", "ariaLabel"], ariaLabelledby: ["aria-labelledby", "ariaLabelledby"], state: "state", editable: ["editable", "editable", import_core.booleanAttribute], optional: ["optional", "optional", import_core.booleanAttribute], completed: ["completed", "completed", import_core.booleanAttribute], hasError: ["hasError", "hasError", import_core.booleanAttribute] }, outputs: { interactedStream: "interacted" }, queries: [{ propertyName: "stepLabel", first: true, predicate: CdkStepLabel, descendants: true }, { propertyName: "_childForms", predicate: (
  // Note: we look for `ControlContainer` here, because both `NgForm` and `FormGroupDirective`
  // provides themselves as such, but we don't want to have a concrete reference to both of
  // the directives. The type is marked as `Partial` in case we run into a class that provides
  // itself as `ControlContainer` but doesn't have the same interface as the directives.
  import_forms.ControlContainer
), descendants: true }], viewQueries: [{ propertyName: "content", first: true, predicate: import_core.TemplateRef, descendants: true, static: true }], exportAs: ["cdkStep"], usesOnChanges: true, ngImport: i0, template: "<ng-template><ng-content/></ng-template>", isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush, encapsulation: i0.ViewEncapsulation.None });
let CdkStep = _CdkStep;
i0.\u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.0-next.2", ngImport: i0, type: CdkStep, decorators: [{
  type: import_core.Component,
  args: [{
    selector: "cdk-step",
    exportAs: "cdkStep",
    template: "<ng-template><ng-content/></ng-template>",
    encapsulation: import_core.ViewEncapsulation.None,
    changeDetection: import_core.ChangeDetectionStrategy.OnPush,
    standalone: true
  }]
}], ctorParameters: () => [{ type: CdkStepper, decorators: [{
  type: import_core.Inject,
  args: [(0, import_core.forwardRef)(() => CdkStepper)]
}] }, { type: void 0, decorators: [{
  type: import_core.Optional
}, {
  type: import_core.Inject,
  args: [STEPPER_GLOBAL_OPTIONS]
}] }], propDecorators: { stepLabel: [{
  type: import_core.ContentChild,
  args: [CdkStepLabel]
}], _childForms: [{
  type: import_core.ContentChildren,
  args: [
    // Note: we look for `ControlContainer` here, because both `NgForm` and `FormGroupDirective`
    // provides themselves as such, but we don't want to have a concrete reference to both of
    // the directives. The type is marked as `Partial` in case we run into a class that provides
    // itself as `ControlContainer` but doesn't have the same interface as the directives.
    import_forms.ControlContainer,
    {
      descendants: true
    }
  ]
}], content: [{
  type: import_core.ViewChild,
  args: [import_core.TemplateRef, { static: true }]
}], stepControl: [{
  type: import_core.Input
}], interactedStream: [{
  type: import_core.Output,
  args: ["interacted"]
}], label: [{
  type: import_core.Input
}], errorMessage: [{
  type: import_core.Input
}], ariaLabel: [{
  type: import_core.Input,
  args: ["aria-label"]
}], ariaLabelledby: [{
  type: import_core.Input,
  args: ["aria-labelledby"]
}], state: [{
  type: import_core.Input
}], editable: [{
  type: import_core.Input,
  args: [{ transform: import_core.booleanAttribute }]
}], optional: [{
  type: import_core.Input,
  args: [{ transform: import_core.booleanAttribute }]
}], completed: [{
  type: import_core.Input,
  args: [{ transform: import_core.booleanAttribute }]
}], hasError: [{
  type: import_core.Input,
  args: [{ transform: import_core.booleanAttribute }]
}] } });
const _CdkStepper = class _CdkStepper {
  /** The index of the selected step. */
  get selectedIndex() {
    return this._selectedIndex;
  }
  set selectedIndex(index) {
    var _a;
    if (this.steps && this._steps) {
      if (!this._isValidIndex(index) && (typeof ngDevMode === "undefined" || ngDevMode)) {
        throw Error("cdkStepper: Cannot assign out-of-bounds value to `selectedIndex`.");
      }
      (_a = this.selected) == null ? void 0 : _a._markAsInteracted();
      if (this._selectedIndex !== index && !this._anyControlsInvalidOrPending(index) && (index >= this._selectedIndex || this.steps.toArray()[index].editable)) {
        this._updateSelectedItemIndex(index);
      }
    } else {
      this._selectedIndex = index;
    }
  }
  /** The step that is selected. */
  get selected() {
    return this.steps ? this.steps.toArray()[this.selectedIndex] : void 0;
  }
  set selected(step) {
    this.selectedIndex = step && this.steps ? this.steps.toArray().indexOf(step) : -1;
  }
  /** Orientation of the stepper. */
  get orientation() {
    return this._orientation;
  }
  set orientation(value) {
    this._orientation = value;
    if (this._keyManager) {
      this._keyManager.withVerticalOrientation(value === "vertical");
    }
  }
  constructor(_dir, _changeDetectorRef, _elementRef) {
    this._dir = _dir;
    this._changeDetectorRef = _changeDetectorRef;
    this._elementRef = _elementRef;
    this._destroyed = new import_rxjs.Subject();
    this.steps = new import_core.QueryList();
    this._sortedHeaders = new import_core.QueryList();
    this.linear = false;
    this._selectedIndex = 0;
    this.selectionChange = new import_core.EventEmitter();
    this.selectedIndexChange = new import_core.EventEmitter();
    this._orientation = "horizontal";
    this._groupId = nextId++;
  }
  ngAfterContentInit() {
    this._steps.changes.pipe((0, import_operators.startWith)(this._steps), (0, import_operators.takeUntil)(this._destroyed)).subscribe((steps) => {
      this.steps.reset(steps.filter((step) => step._stepper === this));
      this.steps.notifyOnChanges();
    });
  }
  ngAfterViewInit() {
    this._stepHeader.changes.pipe((0, import_operators.startWith)(this._stepHeader), (0, import_operators.takeUntil)(this._destroyed)).subscribe((headers) => {
      this._sortedHeaders.reset(headers.toArray().sort((a, b) => {
        const documentPosition = a._elementRef.nativeElement.compareDocumentPosition(b._elementRef.nativeElement);
        return documentPosition & Node.DOCUMENT_POSITION_FOLLOWING ? -1 : 1;
      }));
      this._sortedHeaders.notifyOnChanges();
    });
    this._keyManager = new import_a11y.FocusKeyManager(this._sortedHeaders).withWrap().withHomeAndEnd().withVerticalOrientation(this._orientation === "vertical");
    (this._dir ? this._dir.change : (0, import_rxjs.of)()).pipe((0, import_operators.startWith)(this._layoutDirection()), (0, import_operators.takeUntil)(this._destroyed)).subscribe((direction) => this._keyManager.withHorizontalOrientation(direction));
    this._keyManager.updateActiveItem(this._selectedIndex);
    this.steps.changes.subscribe(() => {
      if (!this.selected) {
        this._selectedIndex = Math.max(this._selectedIndex - 1, 0);
      }
    });
    if (!this._isValidIndex(this._selectedIndex)) {
      this._selectedIndex = 0;
    }
  }
  ngOnDestroy() {
    var _a;
    (_a = this._keyManager) == null ? void 0 : _a.destroy();
    this.steps.destroy();
    this._sortedHeaders.destroy();
    this._destroyed.next();
    this._destroyed.complete();
  }
  /** Selects and focuses the next step in list. */
  next() {
    this.selectedIndex = Math.min(this._selectedIndex + 1, this.steps.length - 1);
  }
  /** Selects and focuses the previous step in list. */
  previous() {
    this.selectedIndex = Math.max(this._selectedIndex - 1, 0);
  }
  /** Resets the stepper to its initial state. Note that this includes clearing form data. */
  reset() {
    this._updateSelectedItemIndex(0);
    this.steps.forEach((step) => step.reset());
    this._stateChanged();
  }
  /** Returns a unique id for each step label element. */
  _getStepLabelId(i) {
    return `cdk-step-label-${this._groupId}-${i}`;
  }
  /** Returns unique id for each step content element. */
  _getStepContentId(i) {
    return `cdk-step-content-${this._groupId}-${i}`;
  }
  /** Marks the component to be change detected. */
  _stateChanged() {
    this._changeDetectorRef.markForCheck();
  }
  /** Returns position state of the step with the given index. */
  _getAnimationDirection(index) {
    const position = index - this._selectedIndex;
    if (position < 0) {
      return this._layoutDirection() === "rtl" ? "next" : "previous";
    } else if (position > 0) {
      return this._layoutDirection() === "rtl" ? "previous" : "next";
    }
    return "current";
  }
  /** Returns the type of icon to be displayed. */
  _getIndicatorType(index, state = STEP_STATE.NUMBER) {
    const step = this.steps.toArray()[index];
    const isCurrentStep = this._isCurrentStep(index);
    return step._displayDefaultIndicatorType ? this._getDefaultIndicatorLogic(step, isCurrentStep) : this._getGuidelineLogic(step, isCurrentStep, state);
  }
  _getDefaultIndicatorLogic(step, isCurrentStep) {
    if (step._showError() && step.hasError && !isCurrentStep) {
      return STEP_STATE.ERROR;
    } else if (!step.completed || isCurrentStep) {
      return STEP_STATE.NUMBER;
    } else {
      return step.editable ? STEP_STATE.EDIT : STEP_STATE.DONE;
    }
  }
  _getGuidelineLogic(step, isCurrentStep, state = STEP_STATE.NUMBER) {
    if (step._showError() && step.hasError && !isCurrentStep) {
      return STEP_STATE.ERROR;
    } else if (step.completed && !isCurrentStep) {
      return STEP_STATE.DONE;
    } else if (step.completed && isCurrentStep) {
      return state;
    } else if (step.editable && isCurrentStep) {
      return STEP_STATE.EDIT;
    } else {
      return state;
    }
  }
  _isCurrentStep(index) {
    return this._selectedIndex === index;
  }
  /** Returns the index of the currently-focused step header. */
  _getFocusIndex() {
    return this._keyManager ? this._keyManager.activeItemIndex : this._selectedIndex;
  }
  _updateSelectedItemIndex(newIndex) {
    const stepsArray = this.steps.toArray();
    this.selectionChange.emit({
      selectedIndex: newIndex,
      previouslySelectedIndex: this._selectedIndex,
      selectedStep: stepsArray[newIndex],
      previouslySelectedStep: stepsArray[this._selectedIndex]
    });
    this._containsFocus() ? this._keyManager.setActiveItem(newIndex) : this._keyManager.updateActiveItem(newIndex);
    this._selectedIndex = newIndex;
    this.selectedIndexChange.emit(this._selectedIndex);
    this._stateChanged();
  }
  _onKeydown(event) {
    const hasModifier = (0, import_keycodes.hasModifierKey)(event);
    const keyCode = event.keyCode;
    const manager = this._keyManager;
    if (manager.activeItemIndex != null && !hasModifier && (keyCode === import_keycodes.SPACE || keyCode === import_keycodes.ENTER)) {
      this.selectedIndex = manager.activeItemIndex;
      event.preventDefault();
    } else {
      manager.setFocusOrigin("keyboard").onKeydown(event);
    }
  }
  _anyControlsInvalidOrPending(index) {
    if (this.linear && index >= 0) {
      return this.steps.toArray().slice(0, index).some((step) => {
        const control = step.stepControl;
        const isIncomplete = control ? control.invalid || control.pending || !step.interacted : !step.completed;
        return isIncomplete && !step.optional && !step._completedOverride;
      });
    }
    return false;
  }
  _layoutDirection() {
    return this._dir && this._dir.value === "rtl" ? "rtl" : "ltr";
  }
  /** Checks whether the stepper contains the focused element. */
  _containsFocus() {
    const stepperElement = this._elementRef.nativeElement;
    const focusedElement = (0, import_platform._getFocusedElementPierceShadowDom)();
    return stepperElement === focusedElement || stepperElement.contains(focusedElement);
  }
  /** Checks whether the passed-in index is a valid step index. */
  _isValidIndex(index) {
    return index > -1 && (!this.steps || index < this.steps.length);
  }
};
_CdkStepper.\u0275fac = i0.\u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "18.2.0-next.2", ngImport: i0, type: _CdkStepper, deps: [{ token: i1.Directionality, optional: true }, { token: i0.ChangeDetectorRef }, { token: i0.ElementRef }], target: i0.\u0275\u0275FactoryTarget.Directive });
_CdkStepper.\u0275dir = i0.\u0275\u0275ngDeclareDirective({ minVersion: "16.1.0", version: "18.2.0-next.2", type: _CdkStepper, isStandalone: true, selector: "[cdkStepper]", inputs: { linear: ["linear", "linear", import_core.booleanAttribute], selectedIndex: ["selectedIndex", "selectedIndex", import_core.numberAttribute], selected: "selected", orientation: "orientation" }, outputs: { selectionChange: "selectionChange", selectedIndexChange: "selectedIndexChange" }, queries: [{ propertyName: "_steps", predicate: CdkStep, descendants: true }, { propertyName: "_stepHeader", predicate: CdkStepHeader, descendants: true }], exportAs: ["cdkStepper"], ngImport: i0 });
let CdkStepper = _CdkStepper;
i0.\u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.0-next.2", ngImport: i0, type: CdkStepper, decorators: [{
  type: import_core.Directive,
  args: [{
    selector: "[cdkStepper]",
    exportAs: "cdkStepper",
    standalone: true
  }]
}], ctorParameters: () => [{ type: i1.Directionality, decorators: [{
  type: import_core.Optional
}] }, { type: i0.ChangeDetectorRef }, { type: i0.ElementRef }], propDecorators: { _steps: [{
  type: import_core.ContentChildren,
  args: [CdkStep, { descendants: true }]
}], _stepHeader: [{
  type: import_core.ContentChildren,
  args: [CdkStepHeader, { descendants: true }]
}], linear: [{
  type: import_core.Input,
  args: [{ transform: import_core.booleanAttribute }]
}], selectedIndex: [{
  type: import_core.Input,
  args: [{ transform: import_core.numberAttribute }]
}], selected: [{
  type: import_core.Input
}], selectionChange: [{
  type: import_core.Output
}], selectedIndexChange: [{
  type: import_core.Output
}], orientation: [{
  type: import_core.Input
}] } });
const _CdkStepperNext = class _CdkStepperNext {
  constructor(_stepper) {
    this._stepper = _stepper;
    this.type = "submit";
  }
};
_CdkStepperNext.\u0275fac = i0.\u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "18.2.0-next.2", ngImport: i0, type: _CdkStepperNext, deps: [{ token: CdkStepper }], target: i0.\u0275\u0275FactoryTarget.Directive });
_CdkStepperNext.\u0275dir = i0.\u0275\u0275ngDeclareDirective({ minVersion: "14.0.0", version: "18.2.0-next.2", type: _CdkStepperNext, isStandalone: true, selector: "button[cdkStepperNext]", inputs: { type: "type" }, host: { listeners: { "click": "_stepper.next()" }, properties: { "type": "type" } }, ngImport: i0 });
let CdkStepperNext = _CdkStepperNext;
i0.\u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.0-next.2", ngImport: i0, type: CdkStepperNext, decorators: [{
  type: import_core.Directive,
  args: [{
    selector: "button[cdkStepperNext]",
    host: {
      "[type]": "type",
      "(click)": "_stepper.next()"
    },
    standalone: true
  }]
}], ctorParameters: () => [{ type: CdkStepper }], propDecorators: { type: [{
  type: import_core.Input
}] } });
const _CdkStepperPrevious = class _CdkStepperPrevious {
  constructor(_stepper) {
    this._stepper = _stepper;
    this.type = "button";
  }
};
_CdkStepperPrevious.\u0275fac = i0.\u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "18.2.0-next.2", ngImport: i0, type: _CdkStepperPrevious, deps: [{ token: CdkStepper }], target: i0.\u0275\u0275FactoryTarget.Directive });
_CdkStepperPrevious.\u0275dir = i0.\u0275\u0275ngDeclareDirective({ minVersion: "14.0.0", version: "18.2.0-next.2", type: _CdkStepperPrevious, isStandalone: true, selector: "button[cdkStepperPrevious]", inputs: { type: "type" }, host: { listeners: { "click": "_stepper.previous()" }, properties: { "type": "type" } }, ngImport: i0 });
let CdkStepperPrevious = _CdkStepperPrevious;
i0.\u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.0-next.2", ngImport: i0, type: CdkStepperPrevious, decorators: [{
  type: import_core.Directive,
  args: [{
    selector: "button[cdkStepperPrevious]",
    host: {
      "[type]": "type",
      "(click)": "_stepper.previous()"
    },
    standalone: true
  }]
}], ctorParameters: () => [{ type: CdkStepper }], propDecorators: { type: [{
  type: import_core.Input
}] } });
const _CdkStepperModule = class _CdkStepperModule {
};
_CdkStepperModule.\u0275fac = i0.\u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "18.2.0-next.2", ngImport: i0, type: _CdkStepperModule, deps: [], target: i0.\u0275\u0275FactoryTarget.NgModule });
_CdkStepperModule.\u0275mod = i0.\u0275\u0275ngDeclareNgModule({ minVersion: "14.0.0", version: "18.2.0-next.2", ngImport: i0, type: _CdkStepperModule, imports: [
  import_bidi.BidiModule,
  CdkStep,
  CdkStepper,
  CdkStepHeader,
  CdkStepLabel,
  CdkStepperNext,
  CdkStepperPrevious
], exports: [CdkStep, CdkStepper, CdkStepHeader, CdkStepLabel, CdkStepperNext, CdkStepperPrevious] });
_CdkStepperModule.\u0275inj = i0.\u0275\u0275ngDeclareInjector({ minVersion: "12.0.0", version: "18.2.0-next.2", ngImport: i0, type: _CdkStepperModule, imports: [import_bidi.BidiModule] });
let CdkStepperModule = _CdkStepperModule;
i0.\u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.0-next.2", ngImport: i0, type: CdkStepperModule, decorators: [{
  type: import_core.NgModule,
  args: [{
    imports: [
      import_bidi.BidiModule,
      CdkStep,
      CdkStepper,
      CdkStepHeader,
      CdkStepLabel,
      CdkStepperNext,
      CdkStepperPrevious
    ],
    exports: [CdkStep, CdkStepper, CdkStepHeader, CdkStepLabel, CdkStepperNext, CdkStepperPrevious]
  }]
}] });
