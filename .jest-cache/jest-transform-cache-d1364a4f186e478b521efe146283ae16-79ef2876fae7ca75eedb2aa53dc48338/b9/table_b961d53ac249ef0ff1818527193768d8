e7bb43150f3db0c1542b2ba1ab49083a
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var table_exports = {};
__export(table_exports, {
  MatCell: () => MatCell,
  MatCellDef: () => MatCellDef,
  MatColumnDef: () => MatColumnDef,
  MatFooterCell: () => MatFooterCell,
  MatFooterCellDef: () => MatFooterCellDef,
  MatFooterRow: () => MatFooterRow,
  MatFooterRowDef: () => MatFooterRowDef,
  MatHeaderCell: () => MatHeaderCell,
  MatHeaderCellDef: () => MatHeaderCellDef,
  MatHeaderRow: () => MatHeaderRow,
  MatHeaderRowDef: () => MatHeaderRowDef,
  MatNoDataRow: () => MatNoDataRow,
  MatRecycleRows: () => MatRecycleRows,
  MatRow: () => MatRow,
  MatRowDef: () => MatRowDef,
  MatTable: () => MatTable,
  MatTableDataSource: () => MatTableDataSource,
  MatTableModule: () => MatTableModule,
  MatTextColumn: () => MatTextColumn
});
module.exports = __toCommonJS(table_exports);
var i0 = __toESM(require("@angular/core"), 1);
var import_core = require("@angular/core");
var import_table = require("@angular/cdk/table");
var import_collections = require("@angular/cdk/collections");
var import_core2 = require("@angular/material/core");
var import_rxjs = require("rxjs");
var import_coercion = require("@angular/cdk/coercion");
var import_operators = require("rxjs/operators");
const _MatRecycleRows = class _MatRecycleRows {
};
_MatRecycleRows.\u0275fac = i0.\u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "18.2.0-next.2", ngImport: i0, type: _MatRecycleRows, deps: [], target: i0.\u0275\u0275FactoryTarget.Directive });
_MatRecycleRows.\u0275dir = i0.\u0275\u0275ngDeclareDirective({ minVersion: "14.0.0", version: "18.2.0-next.2", type: _MatRecycleRows, isStandalone: true, selector: "mat-table[recycleRows], table[mat-table][recycleRows]", providers: [{ provide: import_collections._VIEW_REPEATER_STRATEGY, useClass: import_collections._RecycleViewRepeaterStrategy }], ngImport: i0 });
let MatRecycleRows = _MatRecycleRows;
i0.\u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.0-next.2", ngImport: i0, type: MatRecycleRows, decorators: [{
  type: import_core.Directive,
  args: [{
    selector: "mat-table[recycleRows], table[mat-table][recycleRows]",
    providers: [{ provide: import_collections._VIEW_REPEATER_STRATEGY, useClass: import_collections._RecycleViewRepeaterStrategy }],
    standalone: true
  }]
}] });
const _MatTable = class _MatTable extends import_table.CdkTable {
  constructor() {
    super(...arguments);
    this.stickyCssClass = "mat-mdc-table-sticky";
    this.needsPositionStickyOnElement = false;
  }
};
_MatTable.\u0275fac = i0.\u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "18.2.0-next.2", ngImport: i0, type: _MatTable, deps: null, target: i0.\u0275\u0275FactoryTarget.Component });
_MatTable.\u0275cmp = i0.\u0275\u0275ngDeclareComponent({ minVersion: "17.0.0", version: "18.2.0-next.2", type: _MatTable, isStandalone: true, selector: "mat-table, table[mat-table]", host: { properties: { "class.mdc-table-fixed-layout": "fixedLayout" }, classAttribute: "mat-mdc-table mdc-data-table__table" }, providers: [
  { provide: import_table.CdkTable, useExisting: _MatTable },
  { provide: import_table.CDK_TABLE, useExisting: _MatTable },
  { provide: import_table._COALESCED_STYLE_SCHEDULER, useClass: import_table._CoalescedStyleScheduler },
  // TODO(michaeljamesparsons) Abstract the view repeater strategy to a directive API so this code
  //  is only included in the build if used.
  { provide: import_collections._VIEW_REPEATER_STRATEGY, useClass: import_collections._DisposeViewRepeaterStrategy },
  // Prevent nested tables from seeing this table's StickyPositioningListener.
  { provide: import_table.STICKY_POSITIONING_LISTENER, useValue: null }
], exportAs: ["matTable"], usesInheritance: true, ngImport: i0, template: `
    <ng-content select="caption"/>
    <ng-content select="colgroup, col"/>

    <!--
      Unprojected content throws a hydration error so we need this to capture it.
      It gets removed on the client so it doesn't affect the layout.
    -->
    @if (_isServer) {
      <ng-content/>
    }

    @if (_isNativeHtmlTable) {
      <thead role="rowgroup">
        <ng-container headerRowOutlet/>
      </thead>
      <tbody class="mdc-data-table__content" role="rowgroup">
        <ng-container rowOutlet/>
        <ng-container noDataRowOutlet/>
      </tbody>
      <tfoot role="rowgroup">
        <ng-container footerRowOutlet/>
      </tfoot>
    } @else {
      <ng-container headerRowOutlet/>
      <ng-container rowOutlet/>
      <ng-container noDataRowOutlet/>
      <ng-container footerRowOutlet/>
    }
  `, isInline: true, styles: [".mat-mdc-table-sticky{position:sticky !important}mat-table{display:block}mat-header-row{min-height:56px}mat-row,mat-footer-row{min-height:48px}mat-row,mat-header-row,mat-footer-row{display:flex;border-width:0;border-bottom-width:1px;border-style:solid;align-items:center;box-sizing:border-box}mat-cell:first-of-type,mat-header-cell:first-of-type,mat-footer-cell:first-of-type{padding-left:24px}[dir=rtl] mat-cell:first-of-type:not(:only-of-type),[dir=rtl] mat-header-cell:first-of-type:not(:only-of-type),[dir=rtl] mat-footer-cell:first-of-type:not(:only-of-type){padding-left:0;padding-right:24px}mat-cell:last-of-type,mat-header-cell:last-of-type,mat-footer-cell:last-of-type{padding-right:24px}[dir=rtl] mat-cell:last-of-type:not(:only-of-type),[dir=rtl] mat-header-cell:last-of-type:not(:only-of-type),[dir=rtl] mat-footer-cell:last-of-type:not(:only-of-type){padding-right:0;padding-left:24px}mat-cell,mat-header-cell,mat-footer-cell{flex:1;display:flex;align-items:center;overflow:hidden;word-wrap:break-word;min-height:inherit}.mat-mdc-table{min-width:100%;border:0;border-spacing:0;table-layout:auto;white-space:normal;background-color:var(--mat-table-background-color, var(--mat-app-surface))}.mdc-data-table__cell{box-sizing:border-box;overflow:hidden;text-align:left;text-overflow:ellipsis}[dir=rtl] .mdc-data-table__cell{text-align:right}.mdc-data-table__cell,.mdc-data-table__header-cell{padding:0 16px}.mat-mdc-header-row{-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;height:var(--mat-table-header-container-height, 56px);color:var(--mat-table-header-headline-color, var(--mat-app-on-surface, rgba(0, 0, 0, 0.87)));font-family:var(--mat-table-header-headline-font, var(--mat-app-title-small-font, Roboto, sans-serif));line-height:var(--mat-table-header-headline-line-height, var(--mat-app-title-small-line-height));font-size:var(--mat-table-header-headline-size, var(--mat-app-title-small-size, 14px));font-weight:var(--mat-table-header-headline-weight, var(--mat-app-title-small-weight, 500))}.mat-mdc-row{height:var(--mat-table-row-item-container-height, 52px);color:var(--mat-table-row-item-label-text-color, var(--mat-app-on-surface, rgba(0, 0, 0, 0.87)))}.mat-mdc-row,.mdc-data-table__content{-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;font-family:var(--mat-table-row-item-label-text-font, var(--mat-app-body-medium-font, Roboto, sans-serif));line-height:var(--mat-table-row-item-label-text-line-height, var(--mat-app-body-medium-line-height));font-size:var(--mat-table-row-item-label-text-size, var(--mat-app-body-medium-size, 14px));font-weight:var(--mat-table-row-item-label-text-weight, var(--mat-app-body-medium-weight))}.mat-mdc-footer-row{-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;height:var(--mat-table-footer-container-height, 52px);color:var(--mat-table-row-item-label-text-color, var(--mat-app-on-surface, rgba(0, 0, 0, 0.87)));font-family:var(--mat-table-footer-supporting-text-font, var(--mat-app-body-medium-font, Roboto, sans-serif));line-height:var(--mat-table-footer-supporting-text-line-height, var(--mat-app-body-medium-line-height));font-size:var(--mat-table-footer-supporting-text-size, var(--mat-app-body-medium-size, 14px));font-weight:var(--mat-table-footer-supporting-text-weight, var(--mat-app-body-medium-weight));letter-spacing:var(--mat-table-footer-supporting-text-tracking, var(--mat-app-body-medium-tracking))}.mat-mdc-header-cell{border-bottom-color:var(--mat-table-row-item-outline-color, var(--mat-app-outline, rgba(0, 0, 0, 0.12)));border-bottom-width:var(--mat-table-row-item-outline-width, 1px);border-bottom-style:solid;letter-spacing:var(--mat-table-header-headline-tracking, var(--mat-app-title-small-tracking));font-weight:inherit;line-height:inherit;box-sizing:border-box;text-overflow:ellipsis;overflow:hidden;outline:none;text-align:left}[dir=rtl] .mat-mdc-header-cell{text-align:right}.mat-mdc-cell{border-bottom-color:var(--mat-table-row-item-outline-color, var(--mat-app-outline, rgba(0, 0, 0, 0.12)));border-bottom-width:var(--mat-table-row-item-outline-width, 1px);border-bottom-style:solid;letter-spacing:var(--mat-table-row-item-label-text-tracking, var(--mat-app-body-medium-tracking));line-height:inherit}.mdc-data-table__row:last-child .mat-mdc-cell{border-bottom:none}.mat-mdc-footer-cell{letter-spacing:var(--mat-table-row-item-label-text-tracking, var(--mat-app-body-medium-tracking))}mat-row.mat-mdc-row,mat-header-row.mat-mdc-header-row,mat-footer-row.mat-mdc-footer-row{border-bottom:none}.mat-mdc-table tbody,.mat-mdc-table tfoot,.mat-mdc-table thead,.mat-mdc-cell,.mat-mdc-footer-cell,.mat-mdc-header-row,.mat-mdc-row,.mat-mdc-footer-row,.mat-mdc-table .mat-mdc-header-cell{background:inherit}.mat-mdc-table mat-header-row.mat-mdc-header-row,.mat-mdc-table mat-row.mat-mdc-row,.mat-mdc-table mat-footer-row.mat-mdc-footer-cell{height:unset}mat-header-cell.mat-mdc-header-cell,mat-cell.mat-mdc-cell,mat-footer-cell.mat-mdc-footer-cell{align-self:stretch}"], dependencies: [{ kind: "directive", type: import_table.HeaderRowOutlet, selector: "[headerRowOutlet]" }, { kind: "directive", type: import_table.DataRowOutlet, selector: "[rowOutlet]" }, { kind: "directive", type: import_table.NoDataRowOutlet, selector: "[noDataRowOutlet]" }, { kind: "directive", type: import_table.FooterRowOutlet, selector: "[footerRowOutlet]" }], changeDetection: i0.ChangeDetectionStrategy.Default, encapsulation: i0.ViewEncapsulation.None });
let MatTable = _MatTable;
i0.\u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.0-next.2", ngImport: i0, type: MatTable, decorators: [{
  type: import_core.Component,
  args: [{ selector: "mat-table, table[mat-table]", exportAs: "matTable", template: `
    <ng-content select="caption"/>
    <ng-content select="colgroup, col"/>

    <!--
      Unprojected content throws a hydration error so we need this to capture it.
      It gets removed on the client so it doesn't affect the layout.
    -->
    @if (_isServer) {
      <ng-content/>
    }

    @if (_isNativeHtmlTable) {
      <thead role="rowgroup">
        <ng-container headerRowOutlet/>
      </thead>
      <tbody class="mdc-data-table__content" role="rowgroup">
        <ng-container rowOutlet/>
        <ng-container noDataRowOutlet/>
      </tbody>
      <tfoot role="rowgroup">
        <ng-container footerRowOutlet/>
      </tfoot>
    } @else {
      <ng-container headerRowOutlet/>
      <ng-container rowOutlet/>
      <ng-container noDataRowOutlet/>
      <ng-container footerRowOutlet/>
    }
  `, host: {
    "class": "mat-mdc-table mdc-data-table__table",
    "[class.mdc-table-fixed-layout]": "fixedLayout"
  }, providers: [
    { provide: import_table.CdkTable, useExisting: MatTable },
    { provide: import_table.CDK_TABLE, useExisting: MatTable },
    { provide: import_table._COALESCED_STYLE_SCHEDULER, useClass: import_table._CoalescedStyleScheduler },
    // TODO(michaeljamesparsons) Abstract the view repeater strategy to a directive API so this code
    //  is only included in the build if used.
    { provide: import_collections._VIEW_REPEATER_STRATEGY, useClass: import_collections._DisposeViewRepeaterStrategy },
    // Prevent nested tables from seeing this table's StickyPositioningListener.
    { provide: import_table.STICKY_POSITIONING_LISTENER, useValue: null }
  ], encapsulation: import_core.ViewEncapsulation.None, changeDetection: import_core.ChangeDetectionStrategy.Default, standalone: true, imports: [import_table.HeaderRowOutlet, import_table.DataRowOutlet, import_table.NoDataRowOutlet, import_table.FooterRowOutlet], styles: [".mat-mdc-table-sticky{position:sticky !important}mat-table{display:block}mat-header-row{min-height:56px}mat-row,mat-footer-row{min-height:48px}mat-row,mat-header-row,mat-footer-row{display:flex;border-width:0;border-bottom-width:1px;border-style:solid;align-items:center;box-sizing:border-box}mat-cell:first-of-type,mat-header-cell:first-of-type,mat-footer-cell:first-of-type{padding-left:24px}[dir=rtl] mat-cell:first-of-type:not(:only-of-type),[dir=rtl] mat-header-cell:first-of-type:not(:only-of-type),[dir=rtl] mat-footer-cell:first-of-type:not(:only-of-type){padding-left:0;padding-right:24px}mat-cell:last-of-type,mat-header-cell:last-of-type,mat-footer-cell:last-of-type{padding-right:24px}[dir=rtl] mat-cell:last-of-type:not(:only-of-type),[dir=rtl] mat-header-cell:last-of-type:not(:only-of-type),[dir=rtl] mat-footer-cell:last-of-type:not(:only-of-type){padding-right:0;padding-left:24px}mat-cell,mat-header-cell,mat-footer-cell{flex:1;display:flex;align-items:center;overflow:hidden;word-wrap:break-word;min-height:inherit}.mat-mdc-table{min-width:100%;border:0;border-spacing:0;table-layout:auto;white-space:normal;background-color:var(--mat-table-background-color, var(--mat-app-surface))}.mdc-data-table__cell{box-sizing:border-box;overflow:hidden;text-align:left;text-overflow:ellipsis}[dir=rtl] .mdc-data-table__cell{text-align:right}.mdc-data-table__cell,.mdc-data-table__header-cell{padding:0 16px}.mat-mdc-header-row{-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;height:var(--mat-table-header-container-height, 56px);color:var(--mat-table-header-headline-color, var(--mat-app-on-surface, rgba(0, 0, 0, 0.87)));font-family:var(--mat-table-header-headline-font, var(--mat-app-title-small-font, Roboto, sans-serif));line-height:var(--mat-table-header-headline-line-height, var(--mat-app-title-small-line-height));font-size:var(--mat-table-header-headline-size, var(--mat-app-title-small-size, 14px));font-weight:var(--mat-table-header-headline-weight, var(--mat-app-title-small-weight, 500))}.mat-mdc-row{height:var(--mat-table-row-item-container-height, 52px);color:var(--mat-table-row-item-label-text-color, var(--mat-app-on-surface, rgba(0, 0, 0, 0.87)))}.mat-mdc-row,.mdc-data-table__content{-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;font-family:var(--mat-table-row-item-label-text-font, var(--mat-app-body-medium-font, Roboto, sans-serif));line-height:var(--mat-table-row-item-label-text-line-height, var(--mat-app-body-medium-line-height));font-size:var(--mat-table-row-item-label-text-size, var(--mat-app-body-medium-size, 14px));font-weight:var(--mat-table-row-item-label-text-weight, var(--mat-app-body-medium-weight))}.mat-mdc-footer-row{-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;height:var(--mat-table-footer-container-height, 52px);color:var(--mat-table-row-item-label-text-color, var(--mat-app-on-surface, rgba(0, 0, 0, 0.87)));font-family:var(--mat-table-footer-supporting-text-font, var(--mat-app-body-medium-font, Roboto, sans-serif));line-height:var(--mat-table-footer-supporting-text-line-height, var(--mat-app-body-medium-line-height));font-size:var(--mat-table-footer-supporting-text-size, var(--mat-app-body-medium-size, 14px));font-weight:var(--mat-table-footer-supporting-text-weight, var(--mat-app-body-medium-weight));letter-spacing:var(--mat-table-footer-supporting-text-tracking, var(--mat-app-body-medium-tracking))}.mat-mdc-header-cell{border-bottom-color:var(--mat-table-row-item-outline-color, var(--mat-app-outline, rgba(0, 0, 0, 0.12)));border-bottom-width:var(--mat-table-row-item-outline-width, 1px);border-bottom-style:solid;letter-spacing:var(--mat-table-header-headline-tracking, var(--mat-app-title-small-tracking));font-weight:inherit;line-height:inherit;box-sizing:border-box;text-overflow:ellipsis;overflow:hidden;outline:none;text-align:left}[dir=rtl] .mat-mdc-header-cell{text-align:right}.mat-mdc-cell{border-bottom-color:var(--mat-table-row-item-outline-color, var(--mat-app-outline, rgba(0, 0, 0, 0.12)));border-bottom-width:var(--mat-table-row-item-outline-width, 1px);border-bottom-style:solid;letter-spacing:var(--mat-table-row-item-label-text-tracking, var(--mat-app-body-medium-tracking));line-height:inherit}.mdc-data-table__row:last-child .mat-mdc-cell{border-bottom:none}.mat-mdc-footer-cell{letter-spacing:var(--mat-table-row-item-label-text-tracking, var(--mat-app-body-medium-tracking))}mat-row.mat-mdc-row,mat-header-row.mat-mdc-header-row,mat-footer-row.mat-mdc-footer-row{border-bottom:none}.mat-mdc-table tbody,.mat-mdc-table tfoot,.mat-mdc-table thead,.mat-mdc-cell,.mat-mdc-footer-cell,.mat-mdc-header-row,.mat-mdc-row,.mat-mdc-footer-row,.mat-mdc-table .mat-mdc-header-cell{background:inherit}.mat-mdc-table mat-header-row.mat-mdc-header-row,.mat-mdc-table mat-row.mat-mdc-row,.mat-mdc-table mat-footer-row.mat-mdc-footer-cell{height:unset}mat-header-cell.mat-mdc-header-cell,mat-cell.mat-mdc-cell,mat-footer-cell.mat-mdc-footer-cell{align-self:stretch}"] }]
}] });
const _MatCellDef = class _MatCellDef extends import_table.CdkCellDef {
};
_MatCellDef.\u0275fac = i0.\u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "18.2.0-next.2", ngImport: i0, type: _MatCellDef, deps: null, target: i0.\u0275\u0275FactoryTarget.Directive });
_MatCellDef.\u0275dir = i0.\u0275\u0275ngDeclareDirective({ minVersion: "14.0.0", version: "18.2.0-next.2", type: _MatCellDef, isStandalone: true, selector: "[matCellDef]", providers: [{ provide: import_table.CdkCellDef, useExisting: _MatCellDef }], usesInheritance: true, ngImport: i0 });
let MatCellDef = _MatCellDef;
i0.\u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.0-next.2", ngImport: i0, type: MatCellDef, decorators: [{
  type: import_core.Directive,
  args: [{
    selector: "[matCellDef]",
    providers: [{ provide: import_table.CdkCellDef, useExisting: MatCellDef }],
    standalone: true
  }]
}] });
const _MatHeaderCellDef = class _MatHeaderCellDef extends import_table.CdkHeaderCellDef {
};
_MatHeaderCellDef.\u0275fac = i0.\u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "18.2.0-next.2", ngImport: i0, type: _MatHeaderCellDef, deps: null, target: i0.\u0275\u0275FactoryTarget.Directive });
_MatHeaderCellDef.\u0275dir = i0.\u0275\u0275ngDeclareDirective({ minVersion: "14.0.0", version: "18.2.0-next.2", type: _MatHeaderCellDef, isStandalone: true, selector: "[matHeaderCellDef]", providers: [{ provide: import_table.CdkHeaderCellDef, useExisting: _MatHeaderCellDef }], usesInheritance: true, ngImport: i0 });
let MatHeaderCellDef = _MatHeaderCellDef;
i0.\u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.0-next.2", ngImport: i0, type: MatHeaderCellDef, decorators: [{
  type: import_core.Directive,
  args: [{
    selector: "[matHeaderCellDef]",
    providers: [{ provide: import_table.CdkHeaderCellDef, useExisting: MatHeaderCellDef }],
    standalone: true
  }]
}] });
const _MatFooterCellDef = class _MatFooterCellDef extends import_table.CdkFooterCellDef {
};
_MatFooterCellDef.\u0275fac = i0.\u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "18.2.0-next.2", ngImport: i0, type: _MatFooterCellDef, deps: null, target: i0.\u0275\u0275FactoryTarget.Directive });
_MatFooterCellDef.\u0275dir = i0.\u0275\u0275ngDeclareDirective({ minVersion: "14.0.0", version: "18.2.0-next.2", type: _MatFooterCellDef, isStandalone: true, selector: "[matFooterCellDef]", providers: [{ provide: import_table.CdkFooterCellDef, useExisting: _MatFooterCellDef }], usesInheritance: true, ngImport: i0 });
let MatFooterCellDef = _MatFooterCellDef;
i0.\u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.0-next.2", ngImport: i0, type: MatFooterCellDef, decorators: [{
  type: import_core.Directive,
  args: [{
    selector: "[matFooterCellDef]",
    providers: [{ provide: import_table.CdkFooterCellDef, useExisting: MatFooterCellDef }],
    standalone: true
  }]
}] });
const _MatColumnDef = class _MatColumnDef extends import_table.CdkColumnDef {
  /** Unique name for this column. */
  get name() {
    return this._name;
  }
  set name(name) {
    this._setNameInput(name);
  }
  /**
   * Add "mat-column-" prefix in addition to "cdk-column-" prefix.
   * In the future, this will only add "mat-column-" and columnCssClassName
   * will change from type string[] to string.
   * @docs-private
   */
  _updateColumnCssClassName() {
    super._updateColumnCssClassName();
    this._columnCssClassName.push(`mat-column-${this.cssClassFriendlyName}`);
  }
};
_MatColumnDef.\u0275fac = i0.\u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "18.2.0-next.2", ngImport: i0, type: _MatColumnDef, deps: null, target: i0.\u0275\u0275FactoryTarget.Directive });
_MatColumnDef.\u0275dir = i0.\u0275\u0275ngDeclareDirective({ minVersion: "14.0.0", version: "18.2.0-next.2", type: _MatColumnDef, isStandalone: true, selector: "[matColumnDef]", inputs: { name: ["matColumnDef", "name"] }, providers: [
  { provide: import_table.CdkColumnDef, useExisting: _MatColumnDef },
  { provide: "MAT_SORT_HEADER_COLUMN_DEF", useExisting: _MatColumnDef }
], usesInheritance: true, ngImport: i0 });
let MatColumnDef = _MatColumnDef;
i0.\u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.0-next.2", ngImport: i0, type: MatColumnDef, decorators: [{
  type: import_core.Directive,
  args: [{
    selector: "[matColumnDef]",
    providers: [
      { provide: import_table.CdkColumnDef, useExisting: MatColumnDef },
      { provide: "MAT_SORT_HEADER_COLUMN_DEF", useExisting: MatColumnDef }
    ],
    standalone: true
  }]
}], propDecorators: { name: [{
  type: import_core.Input,
  args: ["matColumnDef"]
}] } });
const _MatHeaderCell = class _MatHeaderCell extends import_table.CdkHeaderCell {
};
_MatHeaderCell.\u0275fac = i0.\u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "18.2.0-next.2", ngImport: i0, type: _MatHeaderCell, deps: null, target: i0.\u0275\u0275FactoryTarget.Directive });
_MatHeaderCell.\u0275dir = i0.\u0275\u0275ngDeclareDirective({ minVersion: "14.0.0", version: "18.2.0-next.2", type: _MatHeaderCell, isStandalone: true, selector: "mat-header-cell, th[mat-header-cell]", host: { attributes: { "role": "columnheader" }, classAttribute: "mat-mdc-header-cell mdc-data-table__header-cell" }, usesInheritance: true, ngImport: i0 });
let MatHeaderCell = _MatHeaderCell;
i0.\u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.0-next.2", ngImport: i0, type: MatHeaderCell, decorators: [{
  type: import_core.Directive,
  args: [{
    selector: "mat-header-cell, th[mat-header-cell]",
    host: {
      "class": "mat-mdc-header-cell mdc-data-table__header-cell",
      "role": "columnheader"
    },
    standalone: true
  }]
}] });
const _MatFooterCell = class _MatFooterCell extends import_table.CdkFooterCell {
};
_MatFooterCell.\u0275fac = i0.\u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "18.2.0-next.2", ngImport: i0, type: _MatFooterCell, deps: null, target: i0.\u0275\u0275FactoryTarget.Directive });
_MatFooterCell.\u0275dir = i0.\u0275\u0275ngDeclareDirective({ minVersion: "14.0.0", version: "18.2.0-next.2", type: _MatFooterCell, isStandalone: true, selector: "mat-footer-cell, td[mat-footer-cell]", host: { classAttribute: "mat-mdc-footer-cell mdc-data-table__cell" }, usesInheritance: true, ngImport: i0 });
let MatFooterCell = _MatFooterCell;
i0.\u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.0-next.2", ngImport: i0, type: MatFooterCell, decorators: [{
  type: import_core.Directive,
  args: [{
    selector: "mat-footer-cell, td[mat-footer-cell]",
    host: {
      "class": "mat-mdc-footer-cell mdc-data-table__cell"
    },
    standalone: true
  }]
}] });
const _MatCell = class _MatCell extends import_table.CdkCell {
};
_MatCell.\u0275fac = i0.\u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "18.2.0-next.2", ngImport: i0, type: _MatCell, deps: null, target: i0.\u0275\u0275FactoryTarget.Directive });
_MatCell.\u0275dir = i0.\u0275\u0275ngDeclareDirective({ minVersion: "14.0.0", version: "18.2.0-next.2", type: _MatCell, isStandalone: true, selector: "mat-cell, td[mat-cell]", host: { classAttribute: "mat-mdc-cell mdc-data-table__cell" }, usesInheritance: true, ngImport: i0 });
let MatCell = _MatCell;
i0.\u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.0-next.2", ngImport: i0, type: MatCell, decorators: [{
  type: import_core.Directive,
  args: [{
    selector: "mat-cell, td[mat-cell]",
    host: {
      "class": "mat-mdc-cell mdc-data-table__cell"
    },
    standalone: true
  }]
}] });
const ROW_TEMPLATE = `<ng-container cdkCellOutlet></ng-container>`;
const _MatHeaderRowDef = class _MatHeaderRowDef extends import_table.CdkHeaderRowDef {
};
_MatHeaderRowDef.\u0275fac = i0.\u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "18.2.0-next.2", ngImport: i0, type: _MatHeaderRowDef, deps: null, target: i0.\u0275\u0275FactoryTarget.Directive });
_MatHeaderRowDef.\u0275dir = i0.\u0275\u0275ngDeclareDirective({ minVersion: "16.1.0", version: "18.2.0-next.2", type: _MatHeaderRowDef, isStandalone: true, selector: "[matHeaderRowDef]", inputs: { columns: ["matHeaderRowDef", "columns"], sticky: ["matHeaderRowDefSticky", "sticky", import_core.booleanAttribute] }, providers: [{ provide: import_table.CdkHeaderRowDef, useExisting: _MatHeaderRowDef }], usesInheritance: true, ngImport: i0 });
let MatHeaderRowDef = _MatHeaderRowDef;
i0.\u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.0-next.2", ngImport: i0, type: MatHeaderRowDef, decorators: [{
  type: import_core.Directive,
  args: [{
    selector: "[matHeaderRowDef]",
    providers: [{ provide: import_table.CdkHeaderRowDef, useExisting: MatHeaderRowDef }],
    inputs: [
      { name: "columns", alias: "matHeaderRowDef" },
      { name: "sticky", alias: "matHeaderRowDefSticky", transform: import_core.booleanAttribute }
    ],
    standalone: true
  }]
}] });
const _MatFooterRowDef = class _MatFooterRowDef extends import_table.CdkFooterRowDef {
};
_MatFooterRowDef.\u0275fac = i0.\u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "18.2.0-next.2", ngImport: i0, type: _MatFooterRowDef, deps: null, target: i0.\u0275\u0275FactoryTarget.Directive });
_MatFooterRowDef.\u0275dir = i0.\u0275\u0275ngDeclareDirective({ minVersion: "16.1.0", version: "18.2.0-next.2", type: _MatFooterRowDef, isStandalone: true, selector: "[matFooterRowDef]", inputs: { columns: ["matFooterRowDef", "columns"], sticky: ["matFooterRowDefSticky", "sticky", import_core.booleanAttribute] }, providers: [{ provide: import_table.CdkFooterRowDef, useExisting: _MatFooterRowDef }], usesInheritance: true, ngImport: i0 });
let MatFooterRowDef = _MatFooterRowDef;
i0.\u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.0-next.2", ngImport: i0, type: MatFooterRowDef, decorators: [{
  type: import_core.Directive,
  args: [{
    selector: "[matFooterRowDef]",
    providers: [{ provide: import_table.CdkFooterRowDef, useExisting: MatFooterRowDef }],
    inputs: [
      { name: "columns", alias: "matFooterRowDef" },
      { name: "sticky", alias: "matFooterRowDefSticky", transform: import_core.booleanAttribute }
    ],
    standalone: true
  }]
}] });
const _MatRowDef = class _MatRowDef extends import_table.CdkRowDef {
};
_MatRowDef.\u0275fac = i0.\u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "18.2.0-next.2", ngImport: i0, type: _MatRowDef, deps: null, target: i0.\u0275\u0275FactoryTarget.Directive });
_MatRowDef.\u0275dir = i0.\u0275\u0275ngDeclareDirective({ minVersion: "14.0.0", version: "18.2.0-next.2", type: _MatRowDef, isStandalone: true, selector: "[matRowDef]", inputs: { columns: ["matRowDefColumns", "columns"], when: ["matRowDefWhen", "when"] }, providers: [{ provide: import_table.CdkRowDef, useExisting: _MatRowDef }], usesInheritance: true, ngImport: i0 });
let MatRowDef = _MatRowDef;
i0.\u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.0-next.2", ngImport: i0, type: MatRowDef, decorators: [{
  type: import_core.Directive,
  args: [{
    selector: "[matRowDef]",
    providers: [{ provide: import_table.CdkRowDef, useExisting: MatRowDef }],
    inputs: [
      { name: "columns", alias: "matRowDefColumns" },
      { name: "when", alias: "matRowDefWhen" }
    ],
    standalone: true
  }]
}] });
const _MatHeaderRow = class _MatHeaderRow extends import_table.CdkHeaderRow {
};
_MatHeaderRow.\u0275fac = i0.\u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "18.2.0-next.2", ngImport: i0, type: _MatHeaderRow, deps: null, target: i0.\u0275\u0275FactoryTarget.Component });
_MatHeaderRow.\u0275cmp = i0.\u0275\u0275ngDeclareComponent({ minVersion: "14.0.0", version: "18.2.0-next.2", type: _MatHeaderRow, isStandalone: true, selector: "mat-header-row, tr[mat-header-row]", host: { attributes: { "role": "row" }, classAttribute: "mat-mdc-header-row mdc-data-table__header-row" }, providers: [{ provide: import_table.CdkHeaderRow, useExisting: _MatHeaderRow }], exportAs: ["matHeaderRow"], usesInheritance: true, ngImport: i0, template: "<ng-container cdkCellOutlet></ng-container>", isInline: true, dependencies: [{ kind: "directive", type: import_table.CdkCellOutlet, selector: "[cdkCellOutlet]" }], changeDetection: i0.ChangeDetectionStrategy.Default, encapsulation: i0.ViewEncapsulation.None });
let MatHeaderRow = _MatHeaderRow;
i0.\u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.0-next.2", ngImport: i0, type: MatHeaderRow, decorators: [{
  type: import_core.Component,
  args: [{
    selector: "mat-header-row, tr[mat-header-row]",
    template: ROW_TEMPLATE,
    host: {
      "class": "mat-mdc-header-row mdc-data-table__header-row",
      "role": "row"
    },
    // See note on CdkTable for explanation on why this uses the default change detection strategy.
    // tslint:disable-next-line:validate-decorators
    changeDetection: import_core.ChangeDetectionStrategy.Default,
    encapsulation: import_core.ViewEncapsulation.None,
    exportAs: "matHeaderRow",
    providers: [{ provide: import_table.CdkHeaderRow, useExisting: MatHeaderRow }],
    standalone: true,
    imports: [import_table.CdkCellOutlet]
  }]
}] });
const _MatFooterRow = class _MatFooterRow extends import_table.CdkFooterRow {
};
_MatFooterRow.\u0275fac = i0.\u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "18.2.0-next.2", ngImport: i0, type: _MatFooterRow, deps: null, target: i0.\u0275\u0275FactoryTarget.Component });
_MatFooterRow.\u0275cmp = i0.\u0275\u0275ngDeclareComponent({ minVersion: "14.0.0", version: "18.2.0-next.2", type: _MatFooterRow, isStandalone: true, selector: "mat-footer-row, tr[mat-footer-row]", host: { attributes: { "role": "row" }, classAttribute: "mat-mdc-footer-row mdc-data-table__row" }, providers: [{ provide: import_table.CdkFooterRow, useExisting: _MatFooterRow }], exportAs: ["matFooterRow"], usesInheritance: true, ngImport: i0, template: "<ng-container cdkCellOutlet></ng-container>", isInline: true, dependencies: [{ kind: "directive", type: import_table.CdkCellOutlet, selector: "[cdkCellOutlet]" }], changeDetection: i0.ChangeDetectionStrategy.Default, encapsulation: i0.ViewEncapsulation.None });
let MatFooterRow = _MatFooterRow;
i0.\u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.0-next.2", ngImport: i0, type: MatFooterRow, decorators: [{
  type: import_core.Component,
  args: [{
    selector: "mat-footer-row, tr[mat-footer-row]",
    template: ROW_TEMPLATE,
    host: {
      "class": "mat-mdc-footer-row mdc-data-table__row",
      "role": "row"
    },
    // See note on CdkTable for explanation on why this uses the default change detection strategy.
    // tslint:disable-next-line:validate-decorators
    changeDetection: import_core.ChangeDetectionStrategy.Default,
    encapsulation: import_core.ViewEncapsulation.None,
    exportAs: "matFooterRow",
    providers: [{ provide: import_table.CdkFooterRow, useExisting: MatFooterRow }],
    standalone: true,
    imports: [import_table.CdkCellOutlet]
  }]
}] });
const _MatRow = class _MatRow extends import_table.CdkRow {
};
_MatRow.\u0275fac = i0.\u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "18.2.0-next.2", ngImport: i0, type: _MatRow, deps: null, target: i0.\u0275\u0275FactoryTarget.Component });
_MatRow.\u0275cmp = i0.\u0275\u0275ngDeclareComponent({ minVersion: "14.0.0", version: "18.2.0-next.2", type: _MatRow, isStandalone: true, selector: "mat-row, tr[mat-row]", host: { attributes: { "role": "row" }, classAttribute: "mat-mdc-row mdc-data-table__row" }, providers: [{ provide: import_table.CdkRow, useExisting: _MatRow }], exportAs: ["matRow"], usesInheritance: true, ngImport: i0, template: "<ng-container cdkCellOutlet></ng-container>", isInline: true, dependencies: [{ kind: "directive", type: import_table.CdkCellOutlet, selector: "[cdkCellOutlet]" }], changeDetection: i0.ChangeDetectionStrategy.Default, encapsulation: i0.ViewEncapsulation.None });
let MatRow = _MatRow;
i0.\u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.0-next.2", ngImport: i0, type: MatRow, decorators: [{
  type: import_core.Component,
  args: [{
    selector: "mat-row, tr[mat-row]",
    template: ROW_TEMPLATE,
    host: {
      "class": "mat-mdc-row mdc-data-table__row",
      "role": "row"
    },
    // See note on CdkTable for explanation on why this uses the default change detection strategy.
    // tslint:disable-next-line:validate-decorators
    changeDetection: import_core.ChangeDetectionStrategy.Default,
    encapsulation: import_core.ViewEncapsulation.None,
    exportAs: "matRow",
    providers: [{ provide: import_table.CdkRow, useExisting: MatRow }],
    standalone: true,
    imports: [import_table.CdkCellOutlet]
  }]
}] });
const _MatNoDataRow = class _MatNoDataRow extends import_table.CdkNoDataRow {
  constructor() {
    super(...arguments);
    this._contentClassName = "mat-mdc-no-data-row";
  }
};
_MatNoDataRow.\u0275fac = i0.\u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "18.2.0-next.2", ngImport: i0, type: _MatNoDataRow, deps: null, target: i0.\u0275\u0275FactoryTarget.Directive });
_MatNoDataRow.\u0275dir = i0.\u0275\u0275ngDeclareDirective({ minVersion: "14.0.0", version: "18.2.0-next.2", type: _MatNoDataRow, isStandalone: true, selector: "ng-template[matNoDataRow]", providers: [{ provide: import_table.CdkNoDataRow, useExisting: _MatNoDataRow }], usesInheritance: true, ngImport: i0 });
let MatNoDataRow = _MatNoDataRow;
i0.\u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.0-next.2", ngImport: i0, type: MatNoDataRow, decorators: [{
  type: import_core.Directive,
  args: [{
    selector: "ng-template[matNoDataRow]",
    providers: [{ provide: import_table.CdkNoDataRow, useExisting: MatNoDataRow }],
    standalone: true
  }]
}] });
const _MatTextColumn = class _MatTextColumn extends import_table.CdkTextColumn {
};
_MatTextColumn.\u0275fac = i0.\u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "18.2.0-next.2", ngImport: i0, type: _MatTextColumn, deps: null, target: i0.\u0275\u0275FactoryTarget.Component });
_MatTextColumn.\u0275cmp = i0.\u0275\u0275ngDeclareComponent({ minVersion: "14.0.0", version: "18.2.0-next.2", type: _MatTextColumn, isStandalone: true, selector: "mat-text-column", usesInheritance: true, ngImport: i0, template: `
    <ng-container matColumnDef>
      <th mat-header-cell *matHeaderCellDef [style.text-align]="justify">
        {{headerText}}
      </th>
      <td mat-cell *matCellDef="let data" [style.text-align]="justify">
        {{dataAccessor(data, name)}}
      </td>
    </ng-container>
  `, isInline: true, dependencies: [{ kind: "directive", type: MatColumnDef, selector: "[matColumnDef]", inputs: ["matColumnDef"] }, { kind: "directive", type: MatHeaderCellDef, selector: "[matHeaderCellDef]" }, { kind: "directive", type: MatHeaderCell, selector: "mat-header-cell, th[mat-header-cell]" }, { kind: "directive", type: MatCellDef, selector: "[matCellDef]" }, { kind: "directive", type: MatCell, selector: "mat-cell, td[mat-cell]" }], changeDetection: i0.ChangeDetectionStrategy.Default, encapsulation: i0.ViewEncapsulation.None });
let MatTextColumn = _MatTextColumn;
i0.\u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.0-next.2", ngImport: i0, type: MatTextColumn, decorators: [{
  type: import_core.Component,
  args: [{
    selector: "mat-text-column",
    template: `
    <ng-container matColumnDef>
      <th mat-header-cell *matHeaderCellDef [style.text-align]="justify">
        {{headerText}}
      </th>
      <td mat-cell *matCellDef="let data" [style.text-align]="justify">
        {{dataAccessor(data, name)}}
      </td>
    </ng-container>
  `,
    encapsulation: import_core.ViewEncapsulation.None,
    // Change detection is intentionally not set to OnPush. This component's template will be provided
    // to the table to be inserted into its view. This is problematic when change detection runs since
    // the bindings in this template will be evaluated _after_ the table's view is evaluated, which
    // mean's the template in the table's view will not have the updated value (and in fact will cause
    // an ExpressionChangedAfterItHasBeenCheckedError).
    // tslint:disable-next-line:validate-decorators
    changeDetection: import_core.ChangeDetectionStrategy.Default,
    standalone: true,
    imports: [MatColumnDef, MatHeaderCellDef, MatHeaderCell, MatCellDef, MatCell]
  }]
}] });
const EXPORTED_DECLARATIONS = [
  // Table
  MatTable,
  MatRecycleRows,
  // Template defs
  MatHeaderCellDef,
  MatHeaderRowDef,
  MatColumnDef,
  MatCellDef,
  MatRowDef,
  MatFooterCellDef,
  MatFooterRowDef,
  // Cell directives
  MatHeaderCell,
  MatCell,
  MatFooterCell,
  // Row directives
  MatHeaderRow,
  MatRow,
  MatFooterRow,
  MatNoDataRow,
  MatTextColumn
];
const _MatTableModule = class _MatTableModule {
};
_MatTableModule.\u0275fac = i0.\u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "18.2.0-next.2", ngImport: i0, type: _MatTableModule, deps: [], target: i0.\u0275\u0275FactoryTarget.NgModule });
_MatTableModule.\u0275mod = i0.\u0275\u0275ngDeclareNgModule({ minVersion: "14.0.0", version: "18.2.0-next.2", ngImport: i0, type: _MatTableModule, imports: [
  import_core2.MatCommonModule,
  import_table.CdkTableModule,
  // Table
  MatTable,
  MatRecycleRows,
  // Template defs
  MatHeaderCellDef,
  MatHeaderRowDef,
  MatColumnDef,
  MatCellDef,
  MatRowDef,
  MatFooterCellDef,
  MatFooterRowDef,
  // Cell directives
  MatHeaderCell,
  MatCell,
  MatFooterCell,
  // Row directives
  MatHeaderRow,
  MatRow,
  MatFooterRow,
  MatNoDataRow,
  MatTextColumn
], exports: [
  import_core2.MatCommonModule,
  // Table
  MatTable,
  MatRecycleRows,
  // Template defs
  MatHeaderCellDef,
  MatHeaderRowDef,
  MatColumnDef,
  MatCellDef,
  MatRowDef,
  MatFooterCellDef,
  MatFooterRowDef,
  // Cell directives
  MatHeaderCell,
  MatCell,
  MatFooterCell,
  // Row directives
  MatHeaderRow,
  MatRow,
  MatFooterRow,
  MatNoDataRow,
  MatTextColumn
] });
_MatTableModule.\u0275inj = i0.\u0275\u0275ngDeclareInjector({ minVersion: "12.0.0", version: "18.2.0-next.2", ngImport: i0, type: _MatTableModule, imports: [import_core2.MatCommonModule, import_table.CdkTableModule, import_core2.MatCommonModule] });
let MatTableModule = _MatTableModule;
i0.\u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.0-next.2", ngImport: i0, type: MatTableModule, decorators: [{
  type: import_core.NgModule,
  args: [{
    imports: [import_core2.MatCommonModule, import_table.CdkTableModule, ...EXPORTED_DECLARATIONS],
    exports: [import_core2.MatCommonModule, EXPORTED_DECLARATIONS]
  }]
}] });
const MAX_SAFE_INTEGER = 9007199254740991;
class MatTableDataSource extends import_collections.DataSource {
  /** Array of data that should be rendered by the table, where each object represents one row. */
  get data() {
    return this._data.value;
  }
  set data(data) {
    data = Array.isArray(data) ? data : [];
    this._data.next(data);
    if (!this._renderChangesSubscription) {
      this._filterData(data);
    }
  }
  /**
   * Filter term that should be used to filter out objects from the data array. To override how
   * data objects match to this filter string, provide a custom function for filterPredicate.
   */
  get filter() {
    return this._filter.value;
  }
  set filter(filter) {
    this._filter.next(filter);
    if (!this._renderChangesSubscription) {
      this._filterData(this.data);
    }
  }
  /**
   * Instance of the MatSort directive used by the table to control its sorting. Sort changes
   * emitted by the MatSort will trigger an update to the table's rendered data.
   */
  get sort() {
    return this._sort;
  }
  set sort(sort) {
    this._sort = sort;
    this._updateChangeSubscription();
  }
  /**
   * Instance of the paginator component used by the table to control what page of the data is
   * displayed. Page changes emitted by the paginator will trigger an update to the
   * table's rendered data.
   *
   * Note that the data source uses the paginator's properties to calculate which page of data
   * should be displayed. If the paginator receives its properties as template inputs,
   * e.g. `[pageLength]=100` or `[pageIndex]=1`, then be sure that the paginator's view has been
   * initialized before assigning it to this data source.
   */
  get paginator() {
    return this._paginator;
  }
  set paginator(paginator) {
    this._paginator = paginator;
    this._updateChangeSubscription();
  }
  constructor(initialData = []) {
    super();
    this._renderData = new import_rxjs.BehaviorSubject([]);
    this._filter = new import_rxjs.BehaviorSubject("");
    this._internalPageChanges = new import_rxjs.Subject();
    this._renderChangesSubscription = null;
    this.sortingDataAccessor = (data, sortHeaderId) => {
      const value = data[sortHeaderId];
      if ((0, import_coercion._isNumberValue)(value)) {
        const numberValue = Number(value);
        return numberValue < MAX_SAFE_INTEGER ? numberValue : value;
      }
      return value;
    };
    this.sortData = (data, sort) => {
      const active = sort.active;
      const direction = sort.direction;
      if (!active || direction == "") {
        return data;
      }
      return data.sort((a, b) => {
        let valueA = this.sortingDataAccessor(a, active);
        let valueB = this.sortingDataAccessor(b, active);
        const valueAType = typeof valueA;
        const valueBType = typeof valueB;
        if (valueAType !== valueBType) {
          if (valueAType === "number") {
            valueA += "";
          }
          if (valueBType === "number") {
            valueB += "";
          }
        }
        let comparatorResult = 0;
        if (valueA != null && valueB != null) {
          if (valueA > valueB) {
            comparatorResult = 1;
          } else if (valueA < valueB) {
            comparatorResult = -1;
          }
        } else if (valueA != null) {
          comparatorResult = 1;
        } else if (valueB != null) {
          comparatorResult = -1;
        }
        return comparatorResult * (direction == "asc" ? 1 : -1);
      });
    };
    this.filterPredicate = (data, filter) => {
      const dataStr = Object.keys(data).reduce((currentTerm, key) => {
        return currentTerm + data[key] + "\u25EC";
      }, "").toLowerCase();
      const transformedFilter = filter.trim().toLowerCase();
      return dataStr.indexOf(transformedFilter) != -1;
    };
    this._data = new import_rxjs.BehaviorSubject(initialData);
    this._updateChangeSubscription();
  }
  /**
   * Subscribe to changes that should trigger an update to the table's rendered rows. When the
   * changes occur, process the current state of the filter, sort, and pagination along with
   * the provided base data and send it to the table for rendering.
   */
  _updateChangeSubscription() {
    var _a;
    const sortChange = this._sort ? (0, import_rxjs.merge)(this._sort.sortChange, this._sort.initialized) : (0, import_rxjs.of)(null);
    const pageChange = this._paginator ? (0, import_rxjs.merge)(this._paginator.page, this._internalPageChanges, this._paginator.initialized) : (0, import_rxjs.of)(null);
    const dataStream = this._data;
    const filteredData = (0, import_rxjs.combineLatest)([dataStream, this._filter]).pipe((0, import_operators.map)(([data]) => this._filterData(data)));
    const orderedData = (0, import_rxjs.combineLatest)([filteredData, sortChange]).pipe((0, import_operators.map)(([data]) => this._orderData(data)));
    const paginatedData = (0, import_rxjs.combineLatest)([orderedData, pageChange]).pipe((0, import_operators.map)(([data]) => this._pageData(data)));
    (_a = this._renderChangesSubscription) == null ? void 0 : _a.unsubscribe();
    this._renderChangesSubscription = paginatedData.subscribe((data) => this._renderData.next(data));
  }
  /**
   * Returns a filtered data array where each filter object contains the filter string within
   * the result of the filterPredicate function. If no filter is set, returns the data array
   * as provided.
   */
  _filterData(data) {
    this.filteredData = this.filter == null || this.filter === "" ? data : data.filter((obj) => this.filterPredicate(obj, this.filter));
    if (this.paginator) {
      this._updatePaginator(this.filteredData.length);
    }
    return this.filteredData;
  }
  /**
   * Returns a sorted copy of the data if MatSort has a sort applied, otherwise just returns the
   * data array as provided. Uses the default data accessor for data lookup, unless a
   * sortDataAccessor function is defined.
   */
  _orderData(data) {
    if (!this.sort) {
      return data;
    }
    return this.sortData(data.slice(), this.sort);
  }
  /**
   * Returns a paged slice of the provided data array according to the provided paginator's page
   * index and length. If there is no paginator provided, returns the data array as provided.
   */
  _pageData(data) {
    if (!this.paginator) {
      return data;
    }
    const startIndex = this.paginator.pageIndex * this.paginator.pageSize;
    return data.slice(startIndex, startIndex + this.paginator.pageSize);
  }
  /**
   * Updates the paginator to reflect the length of the filtered data, and makes sure that the page
   * index does not exceed the paginator's last page. Values are changed in a resolved promise to
   * guard against making property changes within a round of change detection.
   */
  _updatePaginator(filteredDataLength) {
    Promise.resolve().then(() => {
      const paginator = this.paginator;
      if (!paginator) {
        return;
      }
      paginator.length = filteredDataLength;
      if (paginator.pageIndex > 0) {
        const lastPageIndex = Math.ceil(paginator.length / paginator.pageSize) - 1 || 0;
        const newPageIndex = Math.min(paginator.pageIndex, lastPageIndex);
        if (newPageIndex !== paginator.pageIndex) {
          paginator.pageIndex = newPageIndex;
          this._internalPageChanges.next();
        }
      }
    });
  }
  /**
   * Used by the MatTable. Called when it connects to the data source.
   * @docs-private
   */
  connect() {
    if (!this._renderChangesSubscription) {
      this._updateChangeSubscription();
    }
    return this._renderData;
  }
  /**
   * Used by the MatTable. Called when it disconnects from the data source.
   * @docs-private
   */
  disconnect() {
    var _a;
    (_a = this._renderChangesSubscription) == null ? void 0 : _a.unsubscribe();
    this._renderChangesSubscription = null;
  }
}
